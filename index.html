<!DOCTYPE html>
<!-- Author: Matthew Richardson -->
<html>

<head>
	<title>Number Space</title>
	<script src="square_mesh_nav.js"></script>
	<script src="sudoku_board.js"></script>
	<script src="vertex_arrays.js"></script>
	<script>

		function onLoad() {

			const canvas = document.getElementById("ns_canvas");
			const context = canvas.getContext("2d");

			canvas.width = innerWidth;
			canvas.height = innerHeight;

			const mouse = { x: 0, y: 0 };

			canvas.onmousemove = function (event) {
				mouse.x = event.clientX;
				mouse.y = event.clientY;
			};

			canvas.onclick = function (event) {
				// debugMode = !debugMode;
				onTile = false;
				tileX = 0;
				tileY = 0;
			};

			const b1 = sudokuBlock([4, 0, 0, 0]);
			const b2 = sudokuBlock([0, 1, 0, 0]);
			b1.linkTo(b2, 0, 2);
			b1.linkTo(b2, 3, 0);

			const len = 200;
			const half = len / 2;
			const midX = (canvas.width - len) / 2;
			const midY = (canvas.height - len) / 2;
			let tileX = 0;
			let tileY = 0;
			const xLim = Math.ceil(midX / len);
			const yLim = Math.ceil(midY / len);
			const walk = gridWalk(b1);
			let onTile = false;
			const xAxis = { a: { x: 0, y: 0 }, b: { x: 1, y: 0 } };
			const yAxis = { a: { x: 0, y: 0 }, b: { x: 0, y: 1 } };

			function drawScene() {
				const dx = Math.floor((mouse.x - midX) / half) - tileX;
				const dy = Math.floor((mouse.y - midY) / half) - tileY;
				if (onTile) {
					if (dx != 0) {
						if (walk.attempt(dx > 0 ? 0 : 1)) {
							tileX += dx;
						} else {
							onTile = false;
						}
					} else if (dy != 0) {
						if (walk.attempt(dy > 0 ? 2 : 3)) {
							tileY += dy;
						} else {
							onTile = false;
						}
					}
				} else if (dx == 0 && dy == 0) {
					onTile = true;
				}
				const pTL = { x: midX + Math.floor(tileX / 2) * len, y: midY + Math.floor(tileY / 2) * len };
				const limits = [
					xLim - Math.floor(tileX / 2), xLim + Math.floor(tileX / 2),
					yLim - Math.floor(tileY / 2), yLim + Math.floor(tileY / 2)
				];
				if (onTile) {
					tileTree(walk.tileWalk(), pTL, mouse, len, limits, context);
				} else {
					const mid = { x: pTL.x + half, y: pTL.y + half };
					tileTree(walk.tileWalk(), pTL, mid, len, limits, context);
				}
			}

			const times = [];
			let fps;

			function drawInfo() {
				const str = "(" + tileX + ", " + tileY + ") fps: " + fps;
				context.fillStyle = "white";
				context.fillText(str, canvas.width - 100, 20);
			}

			(function animate() {
				context.clearRect(0, 0, canvas.width, canvas.height);
				drawScene();
				if (true) {
					const now = performance.now();
					while (times.length > 0 && times[0] <= now - 1000) {
						times.shift();
					}
					times.push(now);
					fps = times.length;
					drawInfo();
				}
				requestAnimationFrame(animate);
			})();

		}

	</script>
</head>

<body onload="onLoad()">
	<canvas id="ns_canvas"></canvas>
	<style>
		* {
			margin: 0;
			padding: 0;
			background-color: #1E1E1E;
		}
	</style>
</body>

</html>